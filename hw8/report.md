# Отчет АКОС ДЗ8
Головина Арина БПИ244  

## Описание работы программы

Реализованы две независимые программы: `client` и `server`, которые обмениваются данными через один общий сегмент разделяемой памяти с именем `/my-shm`.  
В разделяемой памяти хранится структура с двумя полями: целое число `value` и флаг `terminate`.  

### Работа клиента (client.c)

1. Клиент открывает объект разделяемой памяти `/my-shm` с правами чтения и записи.  
2. Задаётся размер этого объекта равным размеру структуры с полями `value` и `terminate`.  
3. Объект разделяемой памяти отображается в адресное пространство процесса, и переменная `data` начинает указывать на эту общую область памяти.  
4. Поле `terminate` инициализируется нулём, что означает «продолжать работу».  
5. Для сигнала `SIGINT` (Ctrl+C) регистрируется обработчик `cleanup_and_exit`, который:
   - записывает в поле `terminate` значение 1, давая понять серверу, что нужно завершаться;
   - удаляет именованный объект разделяемой памяти (`shm_unlink("/my-shm")`), чтобы сегмент не остался в системе после завершения;
   - завершает процесс клиента через `exit(0)`.  
6. В основном цикле клиент, пока `terminate == 0`:
   - раз в секунду генерирует случайное число в диапазоне от 0 до 999;
   - записывает его в поле `data->value` в разделяемой памяти;
   - выводит это число на экран в виде `Client generated: <число>`.  
7. Когда поле `terminate` становится равным 1 (либо из-за сигнала, либо потому что сервер поставил флаг), клиент выходит из цикла, закрывает дескриптор разделяемой памяти и завершает работу.  

Клиент автоматически генерирует числа и записывает их в общий сегмент, а также отвечает за его удаление при корректном завершении.  

### Работа сервера (server.c)

1. Сервер открывает уже существующий объект разделяемой памяти `/my-shm` с правами чтения и записи.  
2. Объект отображается в адресное пространство процесса, и переменная `data` указывает на ту же общую область памяти, что и у клиента.  
3. Для сигнала `SIGINT` (Ctrl+C) регистрируется обработчик `cleanup_and_exit`, который:
   - устанавливает поле `terminate` в 1, сигнализируя клиенту о необходимости завершения;
   - завершает процесс сервера через `exit(0)`.  
4. В основном цикле сервер, пока `terminate == 0`:
   - раз в секунду читает текущее значение `data->value` из разделяемой памяти;
   - выводит его на экран в виде `Server read: <число>`.  
5. Как только значение `terminate` становится равным 1 (его мог изменить сам сервер в обработчике сигнала или клиент), сервер выходит из цикла, закрывает дескриптор разделяемой памяти и завершает работу.  

Сервер только читает данные, записанные клиентом, и завершает свою работу синхронно с клиентом по общему флагу `terminate`.  

---

## Вариант корректного завершения

1. В разделеяемой памяти используется общее поле `terminate` (флаг завершения), к которому имеют доступ и клиент, и сервер.  
2. Оба процесса в своих основных циклах регулярно проверяют значение флага terminate.
3. Для обработки сигнала прерывания с клавиатуры (Ctrl+C) в обоих процессах установлен обработчик `cleanup_and_exit`:  
   - если сигнал получен клиентом:
     - клиент устанавливает `terminate = 1` в разделяемой памяти;
     - удаляет именованный объект разделяемой памяти с помощью `shm_unlink("/my-shm")`, чтобы сегмент не остался в системе;
     - завершает работу;  
   - если сигнал получен сервером:
     - сервер устанавливает `terminate = 1` в разделяемой памяти;
     - завершается сам.  
4. Благодаря тому, что оба процесса постоянно проверяют общее поле `terminate`, при завершении любого из них второй процесс корректно выходит из цикла чтения/записи и завершает работу.  
5. Сегмент разделяемой памяти удаляется клиентом через `shm_unlink`.   

---

## Инструкция по запуску

### 1. Компиляция

В каталоге с файлами `client.c` и `server.c` выполнить команды компиляции:

```
gcc client.c -o client
gcc server.c -o server
``` 

### 2. Запуск программ

Нужно два терминала.

1. **В первом терминале** запустить клиента:

```
./client
```


2. **Во втором терминале** запустить сервер:

```
./server
```



### 3. Корректное завершение работы

Чтобы завершить работу, достаточно нажать **Ctrl+C**:
- либо в окне клиента,  
- либо в окне сервера.  

В результате:

- оба процесса завершаются;  
- сегмент разделяемой памяти удалён. 
