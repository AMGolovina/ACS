# Отчет АКОС ИДЗ 3
Головина Арина БПИ244  

## Вариант 5
Задача о читателях и писателях. Базу данных, представленную массивом целых положительных чисел, разделяют два типа процессов: N читателей и K писателей. 
Читатели периодически просматривают случайные записи базы данных и выводят свой номер (например, PID), индекс записи, ее значение, а также вычисленное значение числа Фибоначчи. 
Писатели изменяют случайные записи на случайное число и также выводят информацию о своем номере, индексе записи, старом значении и новом значении. 
Предполагается, что в начале БД находится в непротиворечивом состоянии (все числа отсортированы, например, по возрастанию). 
Каждая отдельная новая запись переводит БД из одного непротиворечивого состояния в другое (то есть, новая сортировка может поменять индексы записей или переставить числа). 
Для предотвращения взаимного влияния транзакций процесс–писатель должен иметь исключительный доступ к БД. 
Если к БД не обращается ни один из процессов–писателей, то выполнять транзакции могут одновременно сколько угодно читателей.
Создать многопроцессное приложение с процессами-писателями и процессами-читателями.

---

## на 4-6 баллов
Программа, в которой один родительский процесс запускает и использует требуемое число дочерних процессов.
### 1. Сценарий решаемой задачи:
База данных - это массив из 20 элементов, которые отсортированны по возрастанию вначале работы программы, следовательно числа от 1 до 20.
Количество писателей и читателей генерится рандомно вначале работы программы максимум может быть 5 писателей и читателей, минимум по одному.
Процессы писатели выбирает рандомный элемент от 1 до 1000.

`parent_sigint(int signo)` - устанавливает `terminate = 1`, чтобы все процессы завершились.

`fib(int n)` - вычисляет числа Фибоначи.

`reader_process(int id)` - процесс-читатель, читает рандомно из базы данных один элемент.

`int_cmp` - сортировка массива по возрастанию.

`writer_process(int id)` - процесс‑писатель, выбирает случайный элемент массива, заменяет его случайным числом от 1 до 1000 и затем пересортировывает весь массив с помощью `qsort` для перехода в новое непротиворечивое состояние.

`cleanup_parent()` - очищает ресурсы.
1. Рандомно задается число читателей и писателей от 1 до 5 в N и K и выводится информация о получившемся количестве в консоль.
2. Создается или открывается`shared memory` и получаем доступ к памяти с проверками на корректность.
3. Инициализируются база данных и служебные поля `read_count` и `terminate`.
4. Создаются семафоры.
5. Устанавливается обработчик `SIGINT`, при нажатии `Ctrl+C` вызывается `parent_sigint` и программа завершается.
6. Далее два цикла создают процессы-писатели и процессы-читатели через `fork()` в функциях `reader_process(i)` и `writer_process(i)`.
7. Родитель ставит `wait()` и ожидая завершения процессов, далее очистка и завершение.
### 2. Семафоры:
Множество процессов взаимодействуют с использованием **неименованных** POSIX семафоров.
- `sem_t mutex;` — семафор, защищающий счётчик активных читателей.
- `sem_t rw_mutex;` — семафор для взаимного исключения между писателями и множеством читателей.
### 3. Обмен данных:
Обмен данными ведется через разделяемую память в стандарте POSIX.

- в `reader_process` читатель читает `shared->db[idx]` и использует общие поля `read_count`, `terminate`.
```
int idx = rand() % 20;
int value = shared->db[idx];
...
shared->read_count++;
...
shared->read_count--;
```
- в `writer_process` писатель читает и меняет элементы массива `shared->db` в той же общей памяти и сортирует массив по возрастанию.
```
int idx = rand() % 20;
int old = shared->db[idx];
int new_val = (rand() % 1000) + 1;
shared->db[idx] = new_val;
qsort(shared->db, 20, sizeof(int), int_cmp);
```
### 4. Завершение программы:
Основной сценарий завершения - по Ctrl+C
### 5. Вывод в общий поток:
- в `reader_process`:
```
printf("READER %d | PID=%d : idx=%d value=%d fib=%d\n", id, getpid(), idx, value, fib_val);
```
`id` - id читателя;

`getpid()` - PID читателя;

`idx` - индекс элемента массива;

`value` - значение элемента массива;

`fib_val` - число Фибонначи для данного значения.
- в `writer_process`:
```
printf("WRITER %d | PID=%d : idx=%d old=%d new=%d\n", id, getpid(), idx, old, new_val);
```
`id` - id писателя;

`getpid()` - PID писателя;

`idx` - индекс элемента массива;

`old` - старое значение элемента массива;

`new_val` - новое значение элемента массива.
### 6. Удаление семафоров и разделяемой памяти по ее завершению:
- неименованные семафоры: `sem_destroy`;
- разделяемая память: `munmap` + `close` + `shm_unlink`.
### 7. Результаты работы программы:
<img width="571" height="386" alt="Снимок экрана 2025-11-29 в 22 11 35" src="https://github.com/user-attachments/assets/0c48ead7-9e90-44b6-8eaf-55cc349336ed" />

---
## на 7-8 баллов
Программа, состоящая из отдельных программ–процессов, запускаемых независимо друг от друга в разных консолях.


**init.c** - файл, который создаёт объект разделяемой памяти, инициализирует в нём структуру базы данных и открывает именованные семафоры для синхронизации процессов, после чего завершается.

**reader.c** - файл, который реализует процесс-читатель(логика такая же как и для задания на 4-6 баллов).

**writer.c** - файл, который реализует процесс-писатель.
### 1. Семафоры:
Множество процессов взаимодействуют с использованием **именованных** POSIX семафоров:
- `/rw_mutex_sem_named` - семафор для защиты счётчика читателей, гарантирует, что при каждом изменении значения количества активных читателей в read_count не возникнет гонки между процессами.
- `/rw_db_sem_named` - семафор для эксклюзивного доступа к базе данных, обеспечивает, что одновременно с писателем к памяти не может обращаться ни один читатель и ни другой писатель.
### 2. Обмен данными:
Обмен данными ведется через разделяемую память в стандарте POSIX. Создаётся именованный объект разделяемой памяти с помощью `shm_open()` и задаётся его размер функцией `ftruncate()`. Затем этот объект отображается в адресное пространство процессов через `mmap()`, что позволяет всем программам работать с одной и той же структурой `shared_t` в общей памяти без копирования данных. Процессы‑читатели и процессы‑писатели открывают тот же объект разделяемой памяти по имени и получают к нему доступ через `mmap()`, после чего читают и изменяют одни и те же элементы массива. 
### 3. Завершение приложения:
Для завершения приложения используются те же подходы, что и в программах на меньший балл: основной сценарий завершения - по Ctrl+C.
### 4. Инструкция по запуску и результаты работы:
1. Открываем три терминала(можно больше смотря сколько писателей и читателей хотим запустить) и во всех терминалах собираем файлы:
```
gcc init.c -o init -pthread
gcc reader.c   -o reader   -pthread
gcc writer.c   -o writer   -pthread
```
2. В одном из терминалов запускаем сначала инициализатор:
```
./init
```
3. В одном из оставшихся запускаем процесс-писатель, в другом - читатель:
```
./reader
```
```
./writer
```
4. Можно еще пооткрывать терминалов, собрать в них три файла и дальше запустить еще процессов читателей и писателей.

Результаты работы для `init.c`:

<img width="571" height="373" alt="Снимок экрана 2025-11-30 в 15 17 18" src="https://github.com/user-attachments/assets/a72de34c-741d-4fec-985a-4c6b2beb75d6" />

Результаты работы для двух процессов-писателей:
<img width="1140" height="374" alt="Снимок экрана 2025-11-30 в 15 20 06" src="https://github.com/user-attachments/assets/9f6277c2-aac4-4883-aaa8-d80c2dc40b6c" />
Результаты работы для двух процессов-читателей:
<img width="1141" height="373" alt="Снимок экрана 2025-11-30 в 15 20 15" src="https://github.com/user-attachments/assets/99e332d6-7b5f-42c7-898f-e4767aa15019" />

---
## на 9 баллов
